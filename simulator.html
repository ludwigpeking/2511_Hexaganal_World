<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>World Simulator</title>
        <script src="marchingSquares.js"></script>
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
                background: #f0f0f0;
            }
            h1 {
                color: #333;
            }
            #controls {
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                margin-bottom: 20px;
            }
            button {
                padding: 10px 20px;
                margin: 5px;
                background: #4caf50;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
            }
            button:hover {
                background: #45a049;
            }
            .button-secondary {
                background: #2196f3;
            }
            .button-secondary:hover {
                background: #0b7dda;
            }
            .button-danger {
                background: #f44336;
            }
            .button-danger:hover {
                background: #da190b;
            }
            .param-group {
                margin: 10px 0;
                padding: 10px;
                background: #f5f5f5;
                border-radius: 4px;
            }
            label {
                display: inline-block;
                margin-right: 10px;
                font-weight: bold;
            }
            input[type="number"] {
                width: 80px;
                padding: 5px;
            }
            input[type="checkbox"] {
                margin-left: 20px;
            }
            #canvas-container {
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                display: inline-block;
            }
            canvas {
                border: 1px solid #ddd;
                cursor: crosshair;
            }
            #info {
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                margin-top: 20px;
                font-size: 14px;
                max-width: 800px;
            }
            .stat-row {
                margin: 5px 0;
            }
            .stat-label {
                font-weight: bold;
                display: inline-block;
                width: 220px;
            }
        </style>
    </head>
    <body>
        <h1>üåç World Simulator</h1>

        <div id="controls">
            <div>
                <button onclick="document.getElementById('fileInput').click()">
                    Load Topology File
                </button>
                <input
                    type="file"
                    id="fileInput"
                    accept=".json"
                    style="display: none"
                    onchange="loadCustomFile(event)"
                />
                <button class="button-secondary" onclick="createRandomRoute()">
                    Create Random Route
                </button>
                <button class="button-secondary" onclick="runSimulationStep()">
                    Run Simulation Step
                </button>
                <button class="button-danger" onclick="clearRoutes()">
                    Clear All Routes
                </button>
                <button class="button-danger" onclick="resetSimulation()">
                    Reset Simulation
                </button>
            </div>

            <div class="param-group">
                <label>Downhill Factor:</label>
                <input
                    type="number"
                    id="downhillFactor"
                    value="0.3"
                    step="0.1"
                    min="0"
                    max="1"
                />

                <label>Flat Terrain Cost:</label>
                <input
                    type="number"
                    id="flatTerrainCost"
                    value="2"
                    step="0.5"
                    min="0.5"
                    max="10"
                />

                <label>Traffic Weight:</label>
                <input
                    type="number"
                    id="trafficWeight"
                    value="3"
                    step="1"
                    min="1"
                    max="10"
                />
            </div>

            <div class="param-group">
                <label>Simulation Speed:</label>
                <input
                    type="number"
                    id="simSpeed"
                    value="1"
                    step="1"
                    min="1"
                    max="10"
                />

                <label>
                    <input
                        type="checkbox"
                        id="autoSimulate"
                        onchange="toggleAutoSimulation()"
                    />
                    Auto-run Simulation
                </label>
            </div>

            <div style="margin-top: 10px">
                <label>
                    <input
                        type="checkbox"
                        id="showElevation"
                        checked
                        onchange="redraw()"
                    />
                    Show Elevation Colors
                </label>
                <label>
                    <input
                        type="checkbox"
                        id="showVertices"
                        onchange="redraw()"
                    />
                    Show Vertices
                </label>
                <label>
                    <input
                        type="checkbox"
                        id="showTraffic"
                        checked
                        onchange="redraw()"
                    />
                    Show Traffic Weights
                </label>
            </div>

            <div id="progress" style="margin-top: 10px; color: #666">
                Click "Load Topology File" to begin
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="mapCanvas" width="2400" height="2400"></canvas>
        </div>

        <div id="info">
            <h3>Instructions</h3>
            <p>1. Load the topology map</p>
            <p>
                2. Click "Create Random Route" to generate a trade route between
                two random edge vertices
            </p>
            <p>
                3. The pathfinding uses A* with terrain resistance based on
                slopes and elevation changes
            </p>
            <p>
                4. Click "Run Simulation Step" to evolve the world (future:
                settlements, resources, etc.)
            </p>
            <p>5. Enable "Auto-run Simulation" for continuous evolution</p>

            <h3 style="margin-top: 20px">Simulation Statistics</h3>
            <div id="sim-stats">
                <div class="stat-row">
                    <span class="stat-label">Simulation Step:</span>
                    <span id="step-count">0</span>
                </div>
            </div>

            <h3 style="margin-top: 20px">Route Statistics</h3>
            <div id="route-stats">No routes created yet</div>
        </div>

        <script>
            let topoData = null;
            let canvas = document.getElementById("mapCanvas");
            let ctx = canvas.getContext("2d");
            let minElevation = 0;
            let maxElevation = 0;
            let routes = [];
            let edgeVertices = [];
            let simulationStep = 0;
            let autoSimInterval = null;

            class Route {
                constructor(start, end, trafficWeight, path) {
                    this.start = start;
                    this.end = end;
                    this.trafficWeight = trafficWeight;
                    this.path = path; // Array of vertex indices
                    this.totalDistance = 0;
                    this.totalElevationGain = 0;
                }
            }

            // Canvas click handler for manual selection
            canvas.addEventListener("click", (event) => {
                if (!topoData) return;
                // Could implement manual start/end point selection here
            });

            async function loadCustomFile(event) {
                const file = event.target.files[0];
                if (!file) return;

                updateProgress("Loading " + file.name + "...");
                try {
                    const text = await file.text();
                    topoData = JSON.parse(text);
                    processData();
                } catch (error) {
                    updateProgress("Error loading file: " + error.message);
                    console.error(error);
                }
            }

            async function loadDefaultMap() {
                updateProgress("Loading topo_2.json...");
                try {
                    const response = await fetch("results/topo_2.json");
                    topoData = await response.json();
                    processData();
                } catch (error) {
                    updateProgress("Error loading file: " + error.message);
                    console.error(error);
                }
            }

            function processData() {
                updateProgress("Processing topology data...");

                // Find elevation range
                minElevation = Infinity;
                maxElevation = -Infinity;
                topoData.vertices.forEach((vertex) => {
                    if (vertex.elevation < minElevation)
                        minElevation = vertex.elevation;
                    if (vertex.elevation > maxElevation)
                        maxElevation = vertex.elevation;
                });

                // Find edge vertices (vertices on the map boundary)
                findEdgeVertices();

                // Initialize vertex traffic values
                topoData.vertices.forEach((vertex) => {
                    vertex.traffic = 0;
                    vertex.g = Infinity; // A* cost from start
                    vertex.h = 0; // A* heuristic to end
                    vertex.f = Infinity; // A* total cost
                    vertex.from = null; // A* parent
                });

                updateProgress("Map loaded successfully!");
                redraw();
            }

            function findEdgeVertices() {
                edgeVertices = [];
                const bounds = topoData.mapping.hexBounds;
                const threshold = 10; // Distance threshold to consider as edge

                topoData.vertices.forEach((vertex) => {
                    const x = vertex.hexCoords.x;
                    const y = vertex.hexCoords.y;

                    if (
                        Math.abs(x - bounds.minX) < threshold ||
                        Math.abs(x - bounds.maxX) < threshold ||
                        Math.abs(y - bounds.minY) < threshold ||
                        Math.abs(y - bounds.maxY) < threshold
                    ) {
                        edgeVertices.push(vertex);
                    }
                });

                console.log(`Found ${edgeVertices.length} edge vertices`);
            }

            function createRandomRoute() {
                if (!topoData || edgeVertices.length < 2) {
                    alert("Please load map data first!");
                    return;
                }

                // Select random start and end from edge vertices
                const start =
                    edgeVertices[
                        Math.floor(Math.random() * edgeVertices.length)
                    ];
                let end;
                let distance;

                // Ensure end is far enough from start
                do {
                    end =
                        edgeVertices[
                            Math.floor(Math.random() * edgeVertices.length)
                        ];
                    const dx = end.hexCoords.x - start.hexCoords.x;
                    const dy = end.hexCoords.y - start.hexCoords.y;
                    distance = Math.sqrt(dx * dx + dy * dy);
                } while (distance < topoData.mapping.hexWidth * 0.5);

                const trafficWeight = parseFloat(
                    document.getElementById("trafficWeight").value
                );

                updateProgress(
                    `Finding route from vertex ${start.index} to ${end.index}...`
                );

                const path = pathFinding(start, end, trafficWeight);

                if (path) {
                    const route = new Route(start, end, trafficWeight, path);
                    calculateRouteStats(route);
                    routes.push(route);

                    updateProgress(
                        `Route created! Length: ${
                            path.length
                        } vertices, Distance: ${route.totalDistance.toFixed(
                            0
                        )}m`
                    );
                    updateRouteStats();
                    redraw();
                } else {
                    updateProgress("Failed to find route!");
                }
            }

            function pathFinding(start, end, trafficWeight) {
                // Reset all vertices
                topoData.vertices.forEach((v) => {
                    v.g = Infinity;
                    v.h = 0;
                    v.f = Infinity;
                    v.from = null;
                });

                const downhillFactor = parseFloat(
                    document.getElementById("downhillFactor").value
                );
                const flatTerrainCost = parseFloat(
                    document.getElementById("flatTerrainCost").value
                );

                let openSet = [];
                let closeSet = [];

                start.g = 0;
                start.h = calculateHeuristic(start, end);
                start.f = start.g + start.h;
                openSet.push(start);

                let current = start;

                while (openSet.length > 0 && current.index !== end.index) {
                    // Sort by f value (lowest first)
                    openSet.sort((a, b) => a.f - b.f);
                    current = openSet.shift();
                    closeSet.push(current);

                    // Check all neighbors
                    for (let neighborData of current.neighbors) {
                        const neighbor = topoData.vertices.find(
                            (v) => v.index === neighborData.vertexIndex
                        );
                        if (!neighbor) continue;

                        if (closeSet.includes(neighbor)) continue;

                        // Calculate movement cost
                        const elevationChange =
                            neighbor.elevation - current.elevation;
                        let terrainCost;

                        if (elevationChange > 0) {
                            // Uphill - full cost
                            terrainCost = elevationChange + flatTerrainCost;
                        } else {
                            // Downhill - reduced cost
                            terrainCost =
                                Math.abs(elevationChange) * downhillFactor +
                                flatTerrainCost;
                        }

                        // Use actual distance from neighbor data
                        const moveCost =
                            current.g +
                            terrainCost *
                                (neighborData.horizontalDistanceMeters / 100);

                        if (moveCost < neighbor.g) {
                            neighbor.from = current;
                            neighbor.g = moveCost;
                            neighbor.h = calculateHeuristic(neighbor, end);
                            neighbor.f = neighbor.g + neighbor.h;

                            if (!openSet.includes(neighbor)) {
                                openSet.push(neighbor);
                            }
                        }
                    }
                }

                // Reconstruct path
                if (current.index === end.index) {
                    const path = [];
                    let node = end;

                    while (node) {
                        path.unshift(node.index);
                        node.traffic += trafficWeight;
                        node = node.from;
                    }

                    return path;
                }

                return null; // No path found
            }

            function calculateHeuristic(from, to) {
                const dx = to.hexCoords.x - from.hexCoords.x;
                const dy = to.hexCoords.y - from.hexCoords.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Convert to meters and scale down
                return (
                    (distance *
                        topoData.mapping.metersPerCanvasPixel *
                        topoData.mapping.hexToCanvasScale) /
                    100
                );
            }

            function calculateRouteStats(route) {
                route.totalDistance = 0;
                route.totalElevationGain = 0;

                for (let i = 0; i < route.path.length - 1; i++) {
                    const currentVertex = topoData.vertices.find(
                        (v) => v.index === route.path[i]
                    );
                    const nextVertex = topoData.vertices.find(
                        (v) => v.index === route.path[i + 1]
                    );

                    // Find neighbor data for distance
                    const neighborData = currentVertex.neighbors.find(
                        (n) => n.vertexIndex === nextVertex.index
                    );

                    if (neighborData) {
                        route.totalDistance +=
                            neighborData.horizontalDistanceMeters;
                        if (neighborData.elevationDiff > 0) {
                            route.totalElevationGain +=
                                neighborData.elevationDiff;
                        }
                    }
                }
            }

            function clearRoutes() {
                routes = [];

                // Reset traffic values
                topoData.vertices.forEach((v) => {
                    v.traffic = 0;
                });

                updateRouteStats();
                redraw();
                updateProgress("All routes cleared");
            }

            function redraw() {
                if (!topoData) return;

                // Clear canvas
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const scale = topoData.mapping.hexToCanvasScale;
                const showElevation =
                    document.getElementById("showElevation").checked;
                const showVertices =
                    document.getElementById("showVertices").checked;
                const showTraffic =
                    document.getElementById("showTraffic").checked;

                // Draw tiles with elevation
                if (showElevation) {
                    drawTilesWithElevation(scale);
                }

                // Draw tile borders
                drawTileBorders(scale);

                // Draw traffic heatmap
                if (showTraffic) {
                    drawTrafficHeatmap(scale);
                }

                // Draw routes
                drawRoutes(scale);

                // Draw vertices
                if (showVertices) {
                    drawVertices(scale);
                }

                // Draw start/end markers
                drawRouteEndpoints(scale);
            }

            function drawTilesWithElevation(scale) {
                const vertexMap = new Map();
                topoData.vertices.forEach((v) => vertexMap.set(v.index, v));

                topoData.tiles.forEach((tile) => {
                    const vertices = tile.vertexIndices.map((vIndex) =>
                        vertexMap.get(vIndex)
                    );
                    if (vertices.some((v) => !v)) return;

                    const elevs = vertices.map((v) => v.elevation);
                    const screenVerts = vertices.map((v) => ({
                        x: v.hexCoords.x * scale,
                        y: v.hexCoords.y * scale,
                    }));

                    const minTileElev = Math.min(...elevs);
                    const baseColor = getElevationColor(
                        minTileElev,
                        minElevation,
                        maxElevation
                    );

                    ctx.fillStyle = baseColor;
                    ctx.beginPath();
                    ctx.moveTo(screenVerts[0].x, screenVerts[0].y);
                    for (let i = 1; i < screenVerts.length; i++) {
                        ctx.lineTo(screenVerts[i].x, screenVerts[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();

                    const contourInterval = (maxElevation - minElevation) / 20;
                    drawQuadContours(
                        ctx,
                        screenVerts,
                        elevs,
                        minElevation,
                        maxElevation,
                        contourInterval
                    );
                });
            }

            function drawTileBorders(scale) {
                const vertexMap = new Map();
                topoData.vertices.forEach((v) => vertexMap.set(v.index, v));

                ctx.strokeStyle = "#cccccc";
                ctx.lineWidth = 0.3;

                topoData.tiles.forEach((tile) => {
                    const vertices = tile.vertexIndices.map((vIndex) =>
                        vertexMap.get(vIndex)
                    );
                    if (vertices.some((v) => !v)) return;

                    ctx.beginPath();
                    ctx.moveTo(
                        vertices[0].hexCoords.x * scale,
                        vertices[0].hexCoords.y * scale
                    );
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(
                            vertices[i].hexCoords.x * scale,
                            vertices[i].hexCoords.y * scale
                        );
                    }
                    ctx.closePath();
                    ctx.stroke();
                });
            }

            function drawTrafficHeatmap(scale) {
                topoData.vertices.forEach((vertex) => {
                    if (vertex.traffic > 0) {
                        const x = vertex.hexCoords.x * scale;
                        const y = vertex.hexCoords.y * scale;
                        const radius = Math.sqrt(vertex.traffic) * 8;

                        const gradient = ctx.createRadialGradient(
                            x,
                            y,
                            0,
                            x,
                            y,
                            radius
                        );
                        gradient.addColorStop(
                            0,
                            `rgba(255, 0, 0, ${Math.min(
                                0.6,
                                vertex.traffic * 0.1
                            )})`
                        );
                        gradient.addColorStop(1, "rgba(255, 0, 0, 0)");

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }

            function drawRoutes(scale) {
                routes.forEach((route) => {
                    ctx.strokeStyle = `rgba(255, 255, 0, 0.8)`;
                    ctx.lineWidth = Math.max(2, route.trafficWeight);
                    ctx.lineCap = "round";
                    ctx.lineJoin = "round";

                    ctx.beginPath();
                    for (let i = 0; i < route.path.length; i++) {
                        const vertex = topoData.vertices.find(
                            (v) => v.index === route.path[i]
                        );
                        const x = vertex.hexCoords.x * scale;
                        const y = vertex.hexCoords.y * scale;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                });
            }

            function drawRouteEndpoints(scale) {
                routes.forEach((route) => {
                    const startVertex = topoData.vertices.find(
                        (v) => v.index === route.start.index
                    );
                    const endVertex = topoData.vertices.find(
                        (v) => v.index === route.end.index
                    );

                    // Draw start point (green)
                    ctx.fillStyle = "lime";
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(
                        startVertex.hexCoords.x * scale,
                        startVertex.hexCoords.y * scale,
                        8,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    ctx.stroke();

                    // Draw end point (red)
                    ctx.fillStyle = "red";
                    ctx.beginPath();
                    ctx.arc(
                        endVertex.hexCoords.x * scale,
                        endVertex.hexCoords.y * scale,
                        8,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    ctx.stroke();
                });
            }

            function drawVertices(scale) {
                ctx.fillStyle = "#000000";
                topoData.vertices.forEach((vertex) => {
                    ctx.beginPath();
                    ctx.arc(
                        vertex.hexCoords.x * scale,
                        vertex.hexCoords.y * scale,
                        1.5,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                });
            }

            function updateRouteStats() {
                if (routes.length === 0) {
                    document.getElementById("route-stats").innerHTML =
                        "No routes created yet";
                    return;
                }

                let html = `<p><strong>Total Routes:</strong> ${routes.length}</p>`;

                routes.forEach((route, index) => {
                    html += `
                        <div class="stat-row">
                            <strong>Route ${index + 1}:</strong>
                            ${route.path.length} vertices, 
                            ${route.totalDistance.toFixed(0)}m distance, 
                            ${route.totalElevationGain.toFixed(
                                0
                            )}m elevation gain,
                            weight: ${route.trafficWeight}
                        </div>
                    `;
                });

                document.getElementById("route-stats").innerHTML = html;
            }

            function updateProgress(message) {
                document.getElementById("progress").textContent = message;
            }

            function updateSimStats() {
                document.getElementById("step-count").textContent =
                    simulationStep;
            }

            function runSimulationStep() {
                if (!topoData) {
                    alert("Please load map data first!");
                    return;
                }

                simulationStep++;
                updateSimStats();

                // Placeholder for future simulation logic
                // This is where you would add:
                // - Settlement growth
                // - Resource extraction
                // - Population movement
                // - Trade evolution
                // - etc.

                updateProgress(`Simulation step ${simulationStep} completed`);

                // Example: Every 5 steps, create a new trade route
                if (simulationStep % 5 === 0 && routes.length < 10) {
                    createRandomRoute();
                }
            }

            function toggleAutoSimulation() {
                const isEnabled =
                    document.getElementById("autoSimulate").checked;

                if (isEnabled) {
                    if (!topoData) {
                        alert("Please load map data first!");
                        document.getElementById("autoSimulate").checked = false;
                        return;
                    }

                    const speed = parseInt(
                        document.getElementById("simSpeed").value
                    );
                    const interval = 1000 / speed; // Convert speed to milliseconds

                    autoSimInterval = setInterval(runSimulationStep, interval);
                    updateProgress("Auto-simulation enabled");
                } else {
                    if (autoSimInterval) {
                        clearInterval(autoSimInterval);
                        autoSimInterval = null;
                    }
                    updateProgress("Auto-simulation disabled");
                }
            }

            function resetSimulation() {
                simulationStep = 0;
                clearRoutes();

                if (autoSimInterval) {
                    clearInterval(autoSimInterval);
                    autoSimInterval = null;
                    document.getElementById("autoSimulate").checked = false;
                }

                updateSimStats();
                updateProgress("Simulation reset");
            }
        </script>
    </body>
</html>
